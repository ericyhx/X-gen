享元模式

面临的问题：
    分析上面的实现，会发现在缺省的模板管理实现中，其实是需要去获取模板的内容的，而且通常需要获取很多次，这该如何实现呢？
    如果把模板的内容读取出来，并缓存起来，然后再需要的时候从缓存中获取，看起来一起都解决了
    但是，还要新的问题，模板还需要提供默认的功能，就是按照配置和默认的语法来替换属性或者方法，而这些功能，除了需要
    模板自身的数据外，还需要从外部传入配置数据；
    这样一来，缓存对象的时候就不应该缓存这些数据了，该怎么办

定义：
    运用共享的技术有效的支持大量细粒度的对象
知识要点
    1：享元模式设计的重点就在于分离变与不变，把一个对象的状态分成内部状态和外部状态，内部状态是不变的，外部状态是可变的，
    然后通过共享不变的部分，达到减少对象数量，并节约内存的目的
    2：在享元模式中，享元对象又有共享与不共享之分，这种情况通常出现在跟组合模式合用的情况，通常共享的是叶子对象，一般不共享
    的部分是由共享部分组合而成的
    3：享元的内部状态和外部状态是独立的，外部状态的变化不应该影响到内部状态，在需要的时候，可以把外部状态传递给享元对象使用
    4：在享元模式中，通常是在第一次享元工厂请求获取共享对象的时候，进行共享对象的初始化，而且多半都是在享元工厂内部实现，
    不会从外部传入共享的对象
    5：在实现享元模式的时候，通常会考虑垃圾清除的问题
本质：分离与共享
何时选用
    1：如果一个应用程序使用大量的细粒度对象，可以使用享元模式来减少对象数量
    2：如果由于使用大量的对象，造成很大的存储开销，可以使用享元模式来减少对象数量，并节约内存
    3：如果对象的大多数状态都可以转变为外部状态，比如通过计算得到，或是从外部传入等，可以使用享元模式来实现内部状态和外部状态的分离
    4：如果不考虑对象的外部状态，可以用相对较少的共享对象取代很多组合对象，可以使用享元模式来共享对象，然后组合对象来使用这些共享
    对象
思路：
    要解决上面的问题，一个很简单的思路就是：把模板本身的内容做成一个享元对象，而不需要缓存的数据，通过方法参数从外部传入，从而
    实现内部状态和外部状态的分离，然后把享元对象缓存起来，会避免多次重复去读取模板的文件，从而减少模板对象的数量，加快程序的运行
